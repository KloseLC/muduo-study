伪共享:
  是指的在目前的缓存机制读写状态下,出现的缓存行共用的原因,是因为多核心在对缓存的condition write/read
  缓存行的状态有4种
    a\修改中,缓存种的数据与内存里面的不一致   modified 并且只有本地一个拷贝
    b\专有的,exclusive  缓存的内容和内存上的一致.且没有其他处理器core拥有这条缓存行
    c\共享 shared  缓存和内存的内容一直,但有其他的处理器数据在这条缓存行
    d\无效的   invalid  本处理器无法使用该缓存行
    
导致伪共享的原因:
  例如c1和c2两个处理器都要读写缓存行H1,那么就会有1个发送RFO消息,要求对H1拥有唯一权限,其他处理器均为无效权限
那么有第三个处理器获取H1的权限时,两个处理消息会发出大量的RFO消息,随着线程的增多RFO也会越来越多,处理器就慢下来了.如果命中不到数据,那就向上层获取L2 L3的缓存,如
果不幸miss那只能从内存中读取.L3已经很影响性能了,内存更慢

解决伪共享:
1\主动填充64个字节的缓存行 避免伪共享

2\考虑项目程序需要不需要优化,没事就不折腾

